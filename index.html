<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Untangle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Untangle your messy thoughts.">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f4f4f2; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
        }
        svg { width: 100vw; height: 100vh; display: block; cursor: grab; }
        svg:active { cursor: grabbing; }
        
        #editing-layer {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            pointer-events: none; 
            z-index: 1000;
        }
        .bubble-input {
            position: absolute;
            background: #fff; 
            border: 2px solid #000; 
            text-align: center; 
            outline: none; 
            font-weight: bold; 
            color: #000;
            padding: 8px; 
            margin: 0; 
            cursor: text; 
            border-radius: 12px;
            pointer-events: auto; 
            transform: translate(-50%, -50%);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            display: none; 
            -webkit-appearance: none;
            z-index: 1001;
        }

        .link-line { stroke-width: 3px; stroke-linecap: round; stroke-opacity: 0.3; fill: none; transition: stroke-opacity 0.2s; }
        .link-hitbox { fill: none; stroke: transparent; stroke-width: 30px; cursor: pointer; pointer-events: all; }
        .link-line.selected { stroke-opacity: 0.9; stroke-width: 5px; stroke: #222 !important; }
        
        .guideline { stroke-width: 2px; pointer-events: none; opacity: 0.6; stroke-linecap: round; stroke-dasharray: 5,5; }
        
        .bubble-label { 
            pointer-events: none; 
            fill: white; 
            font-weight: bold; 
            text-anchor: middle; 
            user-select: none; 
        }

        .node-circle circle.main-circle { cursor: pointer; pointer-events: all; }
        .node-circle.selected circle.main-circle { stroke: #000; stroke-width: 4px; }

        .delete-btn-group { cursor: pointer; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
        .delete-btn-group.visible { opacity: 1; pointer-events: all; }
        .delete-btn-circle { fill: #ff4d4f; }
        .delete-btn-text { fill: white; font-size: 16px; font-weight: bold; pointer-events: none; }

        .node-delete-trigger { fill: #ff4d4f; cursor: pointer; opacity: 0; pointer-events: all; }
        .node-group:hover .node-delete-trigger, .node-group:active .node-delete-trigger { opacity: 1; }
        .node-delete-x { fill: white; font-size: 12px; pointer-events: none; font-weight: bold; opacity: 0; }
        .node-group:hover .node-delete-x, .node-group:active .node-delete-x { opacity: 1; }

        .controls { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 2000; }
        .btn { 
            padding: 12px 20px; border-radius: 30px; border: none; cursor: pointer; 
            background: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
            font-weight: bold; color: #555; font-size: 14px;
        }
        .btn-save { background: #000; color: white; }
        .toast { 
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); 
            background: rgba(0, 0, 0, 0.85); color: white; padding: 14px 28px; 
            border-radius: 40px; font-size: 14px; font-weight: bold; z-index: 3000; 
            opacity: 0; transition: opacity 0.3s; pointer-events: none; 
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

<div class="controls">
    <button class="btn btn-clear" onclick="clearMap()">Clear</button>
    <button class="btn btn-save" onclick="saveMap()">Save</button>
</div>

<div id="editing-layer">
    <input type="text" id="global-input" class="bubble-input" spellcheck="false">
</div>

<div id="toast" class="toast">已儲存！</div>

<svg id="canvas"><defs id="svg-defs"></defs></svg>

<script>
    const width = window.innerWidth, height = window.innerHeight;
    const baseRadius = 50, growth = 1.05;
    const DEFAULT_TEXT = "Thought";
    const colorPalette = ["#AAB1B7", "#8BA8C1", "#679BBF", "#4EA5A5", "#57B18A", "#8AB96E", "#BDB45D", "#D4A252", "#E28D52", "#ED7456", "#F45B5B", "#E05174", "#C1538E", "#9C5DA5", "#7B64B1", "#5E69B5", "#4A7FB9", "#3F94B7", "#38A8A8", "#32B78D"];

    let nodes = [], links = [], sourceNode = null, selectedLinkId = null, isSpaceDown = false, mousePos = { x: 0, y: 0 }, editingNode = null;
    let dragDistance = 0;

    const svg = d3.select("#canvas");
    const container = svg.append("g");
    const defs = d3.select("#svg-defs");
    const linkLayer = container.append("g").attr("class", "link-layer");
    const uiLayer = container.append("g").attr("class", "ui-layer"); 
    const nodeLayer = container.append("g").attr("class", "node-layer");
    const textLayer = container.append("g").attr("class", "text-layer");
    const topUiLayer = container.append("g").attr("class", "top-ui-layer");
    const guideline = uiLayer.append("line").attr("class", "guideline").style("display", "none");
    const globalInput = document.getElementById('global-input');

    const zoom = d3.zoom().scaleExtent([0.1, 8]).on("zoom", (e) => {
        container.attr("transform", e.transform);
        if(editingNode) updateInputPosition();
    });
    
    svg.call(zoom).on("dblclick.zoom", null);

    const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(200).strength(0.7))
        .force("charge", d3.forceManyBody().strength(-100)) 
        .force("collide", d3.forceCollide().radius(d => getRadius(d) + 40))
        .on("tick", ticked);

    function getRadius(d) { return baseRadius * Math.pow(growth, Math.min(d.count || 0, 100)); }
    function getLevelColor(count) { return colorPalette[Math.min(count || 0, 19)]; }
    function getGradId(d) { 
        const s = d.source.id !== undefined ? d.source.id : d.source;
        const t = d.target.id !== undefined ? d.target.id : d.target;
        return `grad-${s}-${t}`; 
    }

    function update() {
        const gradients = defs.selectAll(".link-gradient").data(links, d => getGradId(d));
        gradients.exit().remove();
        gradients.enter().append("linearGradient").attr("class", "link-gradient").attr("id", d => getGradId(d)).attr("gradientUnits", "userSpaceOnUse")
            .call(g => { 
                g.append("stop").attr("offset", "10%").attr("class", "stop-start"); 
                g.append("stop").attr("offset", "90%").attr("class", "stop-end"); 
            });

        const linkGroups = linkLayer.selectAll(".link-group").data(links, d => getGradId(d));
        linkGroups.exit().remove();
        const lgEnter = linkGroups.enter().append("g").attr("class", "link-group");
        lgEnter.append("line").attr("class", "link-hitbox").on("click", (e, d) => { 
            e.stopPropagation(); 
            selectedLinkId = (selectedLinkId === getGradId(d)) ? null : getGradId(d); 
            update(); 
        });
        lgEnter.append("line").attr("class", "link-line");
        linkLayer.selectAll(".link-line").classed("selected", d => getGradId(d) === selectedLinkId);

        const linkDeleteBtns = topUiLayer.selectAll(".link-delete-btn").data(links, d => getGradId(d));
        linkDeleteBtns.exit().remove();
        linkDeleteBtns.enter().append("g").attr("class", "link-delete-btn delete-btn-group").on("click", (e, d) => { 
            e.stopPropagation(); links = links.filter(l => l !== d); selectedLinkId = null; recalculateCounts(); update(); 
        }).call(g => { 
            g.append("circle").attr("class", "delete-btn-circle").attr("r", 14); 
            g.append("text").attr("class", "delete-btn-text").text("×").attr("text-anchor", "middle").attr("dy", 6); 
        });
        topUiLayer.selectAll(".link-delete-btn").classed("visible", d => getGradId(d) === selectedLinkId);

        const nodeCircles = nodeLayer.selectAll(".node-circle").data(nodes, d => d.id);
        nodeCircles.exit().remove();
        const cEnter = nodeCircles.enter().append("g").attr("class", "node-circle")
            .call(d3.drag()
                .on("start", (e, d) => {
                    dragDistance = 0;
                    if (!e.active) simulation.alphaTarget(0.2).restart();
                    d.fx = d.x; d.fy = d.y;
                })
                .on("drag", (e, d) => {
                    dragDistance += Math.hypot(e.dx, e.dy);
                    d.fx = e.x; d.fy = e.y;
                })
                .on("end", (e, d) => {
                    if (!e.active) simulation.alphaTarget(0);
                    if (dragDistance < 5) {
                        handleNodeClick(e, d);
                    }
                })
            );
        cEnter.append("circle").attr("class", "main-circle");

        const nodeGroups = textLayer.selectAll(".node-group").data(nodes, d => d.id);
        nodeGroups.exit().remove();
        const uiEnter = nodeGroups.enter().append("g").attr("class", "node-group").attr("data-id", d => d.id);
        uiEnter.append("circle").attr("class", "node-delete-trigger").attr("r", 14).on("click", (e, d) => { e.stopPropagation(); deleteNode(d); });
        uiEnter.append("text").attr("class", "node-delete-x").text("×").attr("text-anchor", "middle").attr("dy", 5);
        uiEnter.append("text").attr("class", "bubble-label");

        nodeLayer.selectAll(".main-circle")
            .attr("r", d => getRadius(d))
            .attr("fill", d => getLevelColor(d.count));
        
        nodeLayer.selectAll(".node-circle").classed("selected", d => d === sourceNode);

        textLayer.selectAll(".node-group").each(function(d) {
            const r = getRadius(d);
            const g = d3.select(this);
            g.select(".node-delete-trigger").attr("cx", r * 0.8).attr("cy", -r * 0.8);
            g.select(".node-delete-x").attr("x", r * 0.8).attr("y", -r * 0.8);
            g.select(".bubble-label")
                .text(d.text)
                .attr("dy", 6)
                .style("font-size", Math.max(14, r * 0.3) + "px")
                .style("opacity", (editingNode === d) ? 0 : 1);
        });

        simulation.nodes(nodes);
        simulation.force("link").links(links);
        simulation.alpha(0.1).restart();
    }

    function ticked() {
        linkLayer.selectAll(".link-line").attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y).attr("stroke", d => `url(#${getGradId(d)})`);
        linkLayer.selectAll(".link-hitbox").attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        topUiLayer.selectAll(".link-delete-btn").attr("transform", d => `translate(${(d.source.x + d.target.x) / 2}, ${(d.source.y + d.target.y) / 2})`);
        nodeLayer.selectAll(".node-circle").attr("transform", d => `translate(${d.x},${d.y})`);
        textLayer.selectAll(".node-group").attr("transform", d => `translate(${d.x},${d.y})`);
        if (sourceNode) drawGuideline();
        if (editingNode) updateInputPosition();
    }

    function handleNodeClick(e, d) {
        if (isSpaceDown) return;
        
        if (sourceNode && sourceNode !== d) {
            handleConnect(d);
        } else if (sourceNode === d) {
            sourceNode = null;
            guideline.style("display", "none");
            startEditing(d);
        } else if (!sourceNode) {
            sourceNode = d;
            update();
        }
    }

    function startEditing(d) {
        if (editingNode === d) return;
        editingNode = d;
        update(); 
        
        globalInput.value = d.text;
        globalInput.style.display = 'block';
        updateInputPosition();
        
        setTimeout(() => {
            globalInput.focus();
            globalInput.setSelectionRange(0, globalInput.value.length);
        }, 50);
    }

    function updateInputPosition() {
        if (!editingNode) return;
        const transform = d3.zoomTransform(svg.node());
        const screenX = editingNode.x * transform.k + transform.x;
        const screenY = editingNode.y * transform.k + transform.y;
        const r = getRadius(editingNode) * transform.k;
        
        globalInput.style.left = `${screenX}px`;
        globalInput.style.top = `${screenY}px`;
        globalInput.style.width = `${Math.max(120, r * 1.8)}px`;
        globalInput.style.fontSize = `${Math.max(16, r * 0.35)}px`; 
    }

    globalInput.addEventListener('input', (e) => { 
        if(editingNode) {
            editingNode.text = e.target.value;
            updateInputPosition();
        }
    });

    globalInput.addEventListener('blur', () => { 
        if (!editingNode) return;
        if (editingNode.text.trim() === "") editingNode.text = DEFAULT_TEXT;
        editingNode = null; 
        globalInput.style.display = 'none'; 
        update(); 
    });

    globalInput.addEventListener('keydown', (e) => { 
        if(e.key === 'Enter') {
            e.preventDefault();
            globalInput.blur();
        }
    });

    function handleConnect(d) {
        if (!sourceNode) return;
        const exists = links.some(l => {
            const sId = l.source.id !== undefined ? l.source.id : l.source;
            const tId = l.target.id !== undefined ? l.target.id : l.target;
            return (sId === sourceNode.id && tId === d.id) || (sId === d.id && tId === sourceNode.id);
        });
        if (!exists && sourceNode !== d) { 
            links.push({ source: sourceNode, target: d }); 
            recalculateCounts(); 
        }
        sourceNode = null; 
        guideline.style("display", "none"); 
        update();
    }

    svg.on("click", function(e) {
        if (isSpaceDown || editingNode) return;
        if (e.target.tagName === "svg" || e.target.id === "canvas") {
            const transform = d3.zoomTransform(svg.node());
            const [mx, my] = d3.pointer(e);
            const realX = (mx - transform.x) / transform.k;
            const realY = (my - transform.y) / transform.k;
            
            const newNode = { id: "node-" + Date.now(), text: DEFAULT_TEXT, count: 0, x: realX, y: realY, fx: null, fy: null };
            nodes.push(newNode);
            
            if (sourceNode) { 
                links.push({ source: sourceNode, target: newNode }); 
                sourceNode = null; 
                guideline.style("display", "none"); 
            }
            
            recalculateCounts();
            update();
            startEditing(newNode);
        }
    });

    svg.on("mousemove touchmove", function(e) {
        const transform = d3.zoomTransform(svg.node());
        const [mx, my] = d3.pointer(e);
        mousePos.x = (mx - transform.x) / transform.k;
        mousePos.y = (my - transform.y) / transform.k;
        if (sourceNode) drawGuideline();
    });

    function drawGuideline() {
        if (!sourceNode) return;
        guideline.style("display", "block")
            .attr("x1", sourceNode.x).attr("y1", sourceNode.y)
            .attr("x2", mousePos.x).attr("y2", mousePos.y)
            .attr("stroke", getLevelColor(sourceNode.count));
    }

    function recalculateCounts() { 
        nodes.forEach(n => {
            n.count = links.filter(l => {
                const sId = l.source.id !== undefined ? l.source.id : l.source;
                const tId = l.target.id !== undefined ? l.target.id : l.target;
                return sId === n.id || tId === n.id;
            }).length;
        }); 
    }

    function deleteNode(node) { 
        nodes = nodes.filter(n => n !== node); 
        links = links.filter(l => {
            const sId = l.source.id !== undefined ? l.source.id : l.source;
            const tId = l.target.id !== undefined ? l.target.id : l.target;
            return sId !== node.id && tId !== node.id;
        }); 
        recalculateCounts(); 
        update(); 
    }

    function clearMap() { if(confirm("確定要清空畫布嗎？")) { nodes = []; links = []; update(); } }
    
    function saveMap() { 
        const data = { nodes, links: links.map(l => ({ sourceId: l.source.id || l.source, targetId: l.target.id || l.target })) };
        localStorage.setItem('concept_map_v3_ios', JSON.stringify(data)); 
        showToast("已儲存畫布！"); 
    }

    function showToast(m) { 
        const t = document.getElementById("toast"); 
        t.innerText = m; 
        t.classList.add("show"); 
        setTimeout(() => t.classList.remove("show"), 2000); 
    }

    window.addEventListener('keydown', e => { 
        if (e.code === 'Space') isSpaceDown = true;
        if (e.key === 'Escape' && editingNode) globalInput.blur();
    });
    window.addEventListener('keyup', e => { if (e.code === 'Space') isSpaceDown = false; });

    const saved = localStorage.getItem('concept_map_v3_ios');
    if (saved) {
        const data = JSON.parse(saved);
        nodes = data.nodes;
        links = data.links.map(l => ({ 
            source: nodes.find(n => n.id === l.sourceId), 
            target: nodes.find(n => n.id === l.targetId) 
        })).filter(l => l.source && l.target);
        recalculateCounts();
        update();
    } else {
        nodes = [{ id: "initial-0", text: "Thought", count: 0, x: width/2, y: height/2, fx: null, fy: null }];
        update();
    }
</script>
</body>
</html>
